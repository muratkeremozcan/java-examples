plugins {
	id 'java'
	id 'checkstyle'
	id 'pmd'
	id 'com.github.spotbugs' version '6.0.24'
	id 'jacoco'
}





group = 'local.quickstart'
version = '0.0.1'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

repositories {
	mavenCentral()
}

def junitJupiterVersion = '5.10.2'
def junitPlatformVersion = '1.10.2'

// Configuration for Google Java Format
configurations {
	googleJavaFormat
}

dependencies {
	googleJavaFormat 'com.google.googlejavaformat:google-java-format:1.24.0:all-deps'
	implementation 'org.apache.commons:commons-math3:3.6.1'
	implementation 'org.apache.commons:commons-lang3:3.14.0'
	implementation 'com.google.guava:guava:33.3.1-jre'
	implementation 'jakarta.validation:jakarta.validation-api:3.1.0'
	implementation 'tech.tablesaw:tablesaw-core:0.43.1'
	implementation 'org.mockito:mockito-core:5.12.0'
	implementation "org.junit.jupiter:junit-jupiter:${junitJupiterVersion}"
	implementation "org.junit.platform:junit-platform-launcher:${junitPlatformVersion}"
	testImplementation "org.junit.jupiter:junit-jupiter:${junitJupiterVersion}"
}

// Code quality and linting configuration
checkstyle {
	toolVersion = '10.17.0'  // Latest stable version
	// Use built-in Google Java Style (no custom config file needed!)
	configFile = resources.text.fromUri("https://raw.githubusercontent.com/checkstyle/checkstyle/checkstyle-10.17.0/src/main/resources/google_checks.xml").asFile()
	ignoreFailures = false
	maxWarnings = 5
}

// Task to get the Google Java Format JAR path
tasks.register('getGoogleJavaFormatJar') {
    group = 'Build Setup'
    description = 'Prints the path to the Google Java Format JAR'
    
    doLast {
        def jarFile = configurations.googleJavaFormat.find { it.name.startsWith('google-java-format') }
        if (jarFile) {
            println jarFile.absolutePath
        } else {
            throw new GradleException('Google Java Format JAR not found in dependencies')
        }
    }
}

pmd {
	toolVersion = '7.0.0'
	ignoreFailures = false
	ruleSets = []
	ruleSetFiles = files("${rootDir}/config/pmd/pmd-ruleset.xml")
}

spotbugs {
	toolVersion = '4.8.6'
	ignoreFailures = false
	effort = com.github.spotbugs.snom.Effort.valueOf('MAX')
	reportLevel = com.github.spotbugs.snom.Confidence.valueOf('MEDIUM')
}

jacoco {
	toolVersion = '0.8.11'
}

// Configure quality checks to apply to all source files
checkstyleMain {
	source = fileTree('src') {
		include '**/*.java'
	}
}

pmdMain {
	source = fileTree('src') {
		include '**/*.java'
	}
}

// SpotBugs will automatically find classes from sourceSets.main
// No additional configuration needed for simple projects

// Handle nested folders under src/ - automatically finds all .java files
sourceSets {
	main {
		java {
			srcDirs = ['src']
			// Include all .java files in src/ and subdirectories
			include '**/*.java'
		}
	}
}

// Run any example by full class name (including folder path)
tasks.register('runExample', {
	group = 'application'
	description = 'Run any example (e.g., ./gradlew -PclassName=example.lesson02.Hello runExample)'
	doLast {
		def className = project.findProperty('className') ?: 'intro.lesson01.WelcomeToJava'
		println "Running: $className"
		javaexec {
			classpath = sourceSets.main.runtimeClasspath
			mainClass = className
		}
	}
})

// List all available examples with their folder structure
tasks.register('listExamples') {
	group = 'help'
	description = 'Show all available example classes with their folder structure'
	doLast {
		sourceSets.main.java.files.each { file ->
			if (file.name.endsWith('.java')) {
				// Get relative path from src/ to show folder structure
				def relativePath = file.path.substring(file.path.indexOf('src/') + 4)
				def className = relativePath.replaceAll('\\.java$', '').replaceAll('/', '.')
				println "Available: $className (in $relativePath)"
			}
		}
	}
}

// Quick run without package complexity
tasks.register('quickRun') {
	group = 'application'
	description = 'Quick compile and run (requires: ./gradlew -PclassName=ClassName quickRun)'
	doLast {
		def className = project.findProperty('className')
		if (!className) {
			throw new GradleException("Please specify className: ./gradlew -PclassName=YourClass quickRun")
		}
		ant.mkdir(dir: "$buildDir/tmp")
		ant.javac(srcdir: 'src', destdir: "$buildDir/tmp", includeantruntime: false)
		javaexec {
			classpath = files("$buildDir/tmp")
			mainClass = className
		}
	}
}

// Simple run by folder/filename (no packages needed)
tasks.register('runSimple', {
    group = 'application'
    description = 'Run example by folder/filename (e.g., ./gradlew -Pexample=01_intro/WelcomeToJava runSimple)'
    dependsOn 'classes'
    doLast {
		def example = project.findProperty('example')
		if (!example) {
			throw new GradleException("Please specify example: ./gradlew -Pexample=folder/filename runSimple")
		}
		
		// Extract folder and filename
		def parts = example.split('/')
		if (parts.length != 2) {
			throw new GradleException("Use format: folder/filename (e.g., 01_intro/WelcomeToJava)")
		}
		
		def folder = parts[0]
		def filename = parts[1]
		def sourceFile = "src/${folder}/${filename}.java"
		
		if (!file(sourceFile).exists()) {
			throw new GradleException("File not found: $sourceFile")
		}
		
		println "Running: $sourceFile"
		
        // Extract class name from filename
        def className = filename.replaceAll('\\.java$', '')
        def runtimeClasspath = sourceSets.main.runtimeClasspath

        javaexec {
            classpath = runtimeClasspath
            mainClass = className
        }
    }
})

// Keep VS Code's default launch classpath (bin/main) populated with the compiled classes.
tasks.register('syncBin', Copy) {
    dependsOn 'classes'
    from layout.buildDirectory.dir('classes/java/main')
    into layout.projectDirectory.dir('bin/main')
}

tasks.named('classes') {
    finalizedBy 'syncBin'
}

tasks.named('runSimple') {
    finalizedBy 'syncBin'
}

// List examples in a simpler format
tasks.register('listSimple') {
	group = 'help'
	description = 'List examples in folder/filename format'
	doLast {
		sourceSets.main.java.files.each { file ->
			if (file.name.endsWith('.java')) {
				def relativePath = file.path.substring(file.path.indexOf('src/') + 4)
				def folder = relativePath.substring(0, relativePath.lastIndexOf('/'))
				def filename = relativePath.substring(relativePath.lastIndexOf('/') + 1)
				println "Available: $folder/$filename"
			}
		}
	}
}

tasks.named('test') {
	useJUnitPlatform()
	testLogging {
		events = ["passed", "skipped", "failed"]
		exceptionFormat = "full"
	}
}

// Convenience tasks for code quality
tasks.register('lint') {
	group = 'verification'
	description = 'Run all code quality checks (Google Style + PMD + SpotBugs)'
	dependsOn 'checkstyleMain', 'pmdMain', 'spotbugsMain'
}

// Auto-format Java code task
tasks.register('format', JavaExec) {
	group = 'formatting'
	description = 'Auto-format Java source files'
	classpath = configurations.googleJavaFormat
	mainClass = 'com.google.googlejavaformat.java.Main'
	// Add JVM arguments to fix Java module system issues
	jvmArgs = [
		'--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED'
	]
	args = ['--replace'] + fileTree('src').matching { include '**/*.java' }.files
}

// Check format without modifying files (for CI)
tasks.register('checkFormat', JavaExec) {
	group = 'verification'
	description = 'Check if Java source files are properly formatted'
	classpath = configurations.googleJavaFormat
	mainClass = 'com.google.googlejavaformat.java.Main'
	jvmArgs = [
		'--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
		'--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED'
	]
	args = ['--dry-run', '--set-exit-if-changed'] + fileTree('src').matching { include '**/*.java' }.files
}

// Task to run all checks before committing
tasks.register('preCommit') {
	group = 'verification'
	description = 'Run all checks before committing code'
	dependsOn 'build', 'lint', 'test'
}
